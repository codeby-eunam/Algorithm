문제 플랫폼: 백준

문제 이름 또는 번호: 4779 / 칸토어 집합

링크: [https://www.acmicpc.net/problem/4779]()

오늘의 메모:

 C로 먼저 풀어서 쉽게쉽게 풀었다. 이런 문제 너무 재밌다.

코드:

```

#include <iostream>

#include <math.h>


void contor(int n) {

    if (n == 1)

    {

        printf("-");

        return ;

    }

    n /= 3;

    contor(n);

    for (int i = 0; i < n; i++)

        printf(" ");

    contor(n);

}


int main(void) {

    int input;

    while (std::cin >> input) {

        int n = pow(3, input);

        contor(n);

        printf("\n");

    }

    return (0);

}

```

## 🧠 코드 리뷰 요약

| 항목                      | 평가       | 설명                                          |

| ------------------------- | ---------- | --------------------------------------------- |

| **기능 정확성**     | ⭐⭐⭐⭐⭐ | 칸토어 집합을 올바르게 출력합니다.            |

| **C++ 문법 일관성** | ⭐⭐☆☆☆ | `std::cin`과 `printf`혼용으로 일관성 낮음 |

| **가독성**          | ⭐⭐⭐⭐☆ | 재귀 구조는 명확하지만 변수 의미가 불분명     |

| **성능**            | ⭐⭐⭐⭐⭐ | 입력 크기 내에서 충분히 빠름                  |

| **확장성**          | ⭐⭐⭐☆☆ | 문자열 기반 출력을 지원하지 않음              |

---

## 🔍 세부 피드백

### 1️⃣ 입출력 일관성

* 현재 `std::cin`(C++)과 `printf`(C)를 함께 사용하고 있습니다.

  → 한쪽으로 통일하는 것이 좋습니다.

  → 예: 모두 `std::cout` / `std::cin` 또는 모두 `printf` / `scanf`

### 2️⃣ `pow(3, input)`

*`pow()`는 `double` 반환이므로, 정수 계산에 부정확할 수 있습니다.

  예: `pow(3, 10)`이 59048.9999 같은 값이 될 수 있음

  → `int` 전용 제곱 함수(`pow_int`)를 직접 구현하는 게 안전합니다.

### 3️⃣ `contor` 함수

*`n`이 “길이(length)”를 의미하지만 변수 이름이 그 의미를 드러내지 않습니다.

  → `contor(int length)`로 변경하면 더 명확합니다.

*`n /= 3;` 보다는 `int part = n / 3;`으로 명시하는 것이 재귀 흐름을 파악하기 쉽습니다.

```

#include <iostream>


int pow_int(int base, int exp)

{

    int res = 1;

    for (int i = 0; i < exp; ++i)

        res *= base;

    return res;

}


void cantor(int length)

{

    if (length == 1)

    {

        std::cout << "-";

        return;

    }


    int part = length / 3;

    cantor(part);

    for (int i = 0; i < part; ++i)

        std::cout << " ";

    cantor(part);

}


int main()

{

    int n;

    while (std::cin >> n)

    {

        int length = pow_int(3, n);

        cantor(length);

        std::cout << "\n";

    }

    return 0;

}

```

소감 : 입출력 일관성이 없는데 왜 동작했지?

```

보통 C와 C++ 입출력을 섞으면 입력 버퍼 동기화 문제가 생깁니다.

하지만 당신의 코드는 다음 이유로 ‘운 좋게’ 안전하게 동작한 거예요:


std::cin으로 입력을 받고,


printf로만 출력함 → 출력 순서가 꼬일 상황이 없음


입력/출력이 서로 섞이지 않으므로 동기화 문제 미발생

```
