문제 플랫폼: 백준

문제 이름 또는 번호: 4779 / 칸토어 집합

링크: [https://www.acmicpc.net/problem/4779]()

오늘의 메모:

어떻게 접근해야할지 몰라서 BIGSOHN에게 물어보았다.

대충 설명을 들으니 어떻게 재귀를 만들어야할지 이해가 되었다.

C언어의 pow는 double이라서 int

입력이 어려워서 GPT의 도움을 받았다.

코드:

```

#include <stdio.h>


int ft_pow(int low, int top)

{

    int res = 1;

    for (int i = 0; i < top; i++)

        res *= low;

    return (res);

}


void contor(int n)

{

    if (n == 1)

    {

        printf("-");

        return ;

    }

    n /= 3;

    contor(n);

    for (int i = 0; i < n; i++)

        printf(" ");

    contor(n);

}


int main(void)

{

    int input;

    while (scanf("%d", &input) != EOF)

    {

        int n = ft_pow(3, input);

        contor(n);

        printf("\n");

    }

    return (0);

}

```

GPT 코드리뷰 :

## 🧠 코드 리뷰 요약

| 항목                  | 평가       | 설명                                      |

| --------------------- | ---------- | ----------------------------------------- |

| **기능 정확성** | ⭐⭐⭐⭐⭐ | 정확하게 칸토어 집합을 출력함             |

| **재귀 설계**   | ⭐⭐⭐⭐☆ | 논리는 완벽하지만 `n`의 의미가 불분명함 |

| **코드 구조**   | ⭐⭐⭐⭐☆ | 함수 이름과 변수명이 직관적이지 않음      |

| **성능**        | ⭐⭐⭐⭐⭐ | 충분히 빠름 (3¹² 정도까지 가능)         |

| **가독성**      | ⭐⭐⭐☆☆ | 들여쓰기 및 변수명 개선 여지 있음         |

🔍 세부 피드백

1️⃣ ft_pow

✅ 직접 구현한 정수 제곱 함수, 좋음.

❗ 인자 이름 low, top은 직관적이지 않음 → base, exp 추천.

💡 math.h의 pow는 double 반환이라 int 버전 직접 구현은 적절함.

2️⃣ contor(int n)

✅ 재귀 구조가 정확함.

❗ n이 "길이"를 의미하지만, 이름이 그 의미를 드러내지 않음 → length 추천.

💡 n /= 3; 대신 int next = n / 3;로 명확히 표현.

💡 문자열로 출력하도록 개선하면 확장성 ↑ (예: 파일 출력, 버퍼 사용 등).

3️⃣ main

✅ 입력이 여러 줄일 때도 정상 동작.

💡 scanf 결과 검사를 통해 입력 오류를 방지할 수 있음.

✨ 개선된 코드 예시

```

#include <stdio.h>


int pow_int(int base, int exp)

{

    int res = 1;

    for (int i = 0; i < exp; i++)

        res *= base;

    return res;

}


void cantor(int length)

{

    if (length == 1)

    {

        printf("-");

        return;

    }


    int part = length / 3;


    cantor(part);

    for (int i = 0; i < part; i++)

        printf(" ");

    cantor(part);

}


int main(void)

{

    int n;

    while (scanf("%d", &n) == 1)

    {

        int length = pow_int(3, n);

        cantor(length);

        printf("\n");

    }

    return 0;

}


💭 추가 제안


배열(char arr[length + 1])에 결과를 저장해 한 번에 출력하면 성능이 향상됩니다.


나중에는 반복문 기반 구현 (비재귀 버전) 으로 확장해보면 학습 효과가 큽니다.

```
