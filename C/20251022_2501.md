문제 플랫폼: 백준

문제 이름 또는 번호: 2501 / 약수 구하기

링크: [https://www.acmicpc.net/problem/2501]()

오늘의 메모:

```
무작정 while문으로 n까지 돌렸는데 시간이 오래 걸리지 않아서 다행이었다!
다음에는 시간을 줄일 수 있는 방법을 찾고 싶다.
```

코드:

```

#include <stdio.h>

int main(void)
{
	int n, k;
	scanf("%d %d", &n, &k);

	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		if (n % i == 0)
		{
			cnt++;
			if (cnt == k)
			{
				printf("%d\n", i);
				return (0);
			}
		}
	}
	printf("0\n");
	return (0);
}
```

GPT 코드리뷰 :

✅ 코드 리뷰 요약
항목	평가	설명
기능 정확성	⭐⭐⭐⭐⭐	완벽하게 동작함
코드 구조	⭐⭐⭐⭐⭐	단순하고 논리 흐름이 명확함
가독성	⭐⭐⭐⭐☆	들여쓰기, 변수명 깔끔함
성능	⭐⭐⭐⭐☆	n이 클 때(최대 10,000 이상)도 충분히 빠름
예외 처리	⭐⭐⭐☆☆	입력이 작거나 k가 큰 경우만 명시적으로 처리 중 (출력 0)
🔍 세부 피드백
1️⃣ 로직 (정확성 ✅)
for (int i = 1; i <= n; i++)
{
    if (n % i == 0)
    {
        cnt++;
        if (cnt == k)
        {
            printf("%d\n", i);
            return (0);
        }
    }
}


완전히 올바릅니다.

n % i == 0으로 약수를 찾고, cnt로 개수를 세는 방식은 기본적이지만 명료합니다.

return (0);을 이용해 조기 종료하는 구조도 아주 깔끔합니다.

💡 개선 여지 (성능 관점):

i를 1부터 n까지 도는 대신, 1부터 n/2까지만 돌고 마지막에 n을 약수로 포함시킬 수도 있습니다.
하지만 n ≤ 10,000 수준에서는 미미한 차이입니다.

2️⃣ 예외 처리
printf("0\n");


k번째 약수가 존재하지 않으면 0 출력 — 명세에 맞습니다.

다만 k <= 0이나 n <= 0 입력 같은 비정상 값은 고려하지 않았지만,
문제 조건상 그런 입력은 주어지지 않으므로 괜찮습니다.

3️⃣ 코드 스타일 / C 스타일 면에서 👍

main(void) 사용 → 표준에 맞는 함수 선언

괄호 {} 일관적이고 들여쓰기 정확함

불필요한 헤더 없음 (<stdio.h>만 필요)

리턴 값 return (0); 사용 👍

✨ 개선 예시 (가독성 + 약간의 최적화)
#include <stdio.h>

int main(void)
{
    int n, k;
    scanf("%d %d", &n, &k);

    int count = 0;

    // 약수 탐색
    for (int i = 1; i <= n; i++)
    {
        if (n % i == 0)
        {
            count++;
            if (count == k)
            {
                printf("%d\n", i);
                return 0;
            }
        }
    }

    // k번째 약수가 없을 경우
    printf("0\n");
    return 0;
}


✅ 변경점

변수명 cnt → count: 의미 명확화

주석으로 논리 단위 구분

return (0); 대신 return 0; (취향 차이지만 일반적 스타일)

구조 및 논리 동일

⚙️ 추가 팁

만약 문제 범위가 훨씬 커진다면 (예: n ≤ 10^9)
다음과 같이 개선할 수 있습니다.

약수는 i와 n / i가 쌍으로 존재하므로,
i * i <= n까지만 탐색하고 결과를 따로 저장해두는 방법 사용

이렇게 하면 시간 복잡도 O(√n) 으로 줄일 수 있습니다.

📘 요약

✅ 논리적으로 완벽한 정답 코드
💡 소형 입력에서는 최적, 대형 입력에서는 O(√n) 개선 가능
✨ 변수명과 입출력 통일성만 조금 다듬으면 완성도 최고 수준
